=============================
The PEAK Rules Core Framework
=============================

This document is for people who are extending the core framework in some
way, e.g. adding custom action types to specialize method combination, or
creating new kinds of engines or conditions.  It isn't intended to be user
documentation for the built-in rule facility.

NOTE: Everything from this point down is just an outline of what will be here
eventually.


------------------
Method Combination
------------------

Method combination is performed using the ``combine_actions()`` API function::

    >>> from peak.rules.framework import combine_actions

``combine_actions()`` takes two arguments: a pair of actions.  They are
compared using ``implies()`` to see if one is more specific than the other.
If so, the more specific action's ``override()`` method is called, passing in
the less-specific action.  If neither action can override the other, the first
action's ``merge()`` method is called, passing in the other action.

In either case, the result of calling the ``merge()`` or ``override()`` method
is returned.

So, to define a custom action type for method combination, it needs to support
``implies()`` operations on its signature(s), and it needs to implement
``merge()`` and ``override()`` methods.


Signature Implication
=====================

The ``implies()`` function is used to determine the logical implication
relationship between two signatures or methods.  A signature ``s1`` implies
signature ``s2`` if ``s2`` will always match an invocation matched by ``s1``.
(Action implication is based on signature implication; see the `Action Types`_
section below for more details.)

For the simplest signatures (tuples of types), this corresponds to a subclass
relationship between the elements of the tuples::

    >>> from peak.rules.framework import implies

    >>> implies(int, object)
    True
    >>> implies(object, int)
    False

    >>> implies(int, str)
    False

    >>> implies(int, int)
    True

    >>> implies( (int,str), (object,object) )
    True

    >>> implies( (object,int), (object,str) )
    False

It's possible for a longer tuple to imply a shorter one::

    >>> implies( (int,int), (object,) )
    True

But not the other way around::

    >>> implies( (int,), (object,object) )
    False

And as a special case of type implication, any classic class implies both
``object`` and ``InstanceType`` -- and nothing else::

    >>> class X: pass
    >>> implies(X, object)
    True
    >>> implies(X, type(X()))
    True




Action Types
============


Method
------

The default action type (for rules with no specified action type) is
``Method``.  A ``Method`` combines a body, signature, precedence, and an
optional "chained" action that it can fall back to.  All of these values
are optional, except for the body::

    >>> from peak.rules.framework import Method

    >>> def dummy(*args, **kw):
    ...     print "called with", args, kw

    >>> meth = Method(dummy, (object,), 1)
    >>> meth
    Method(<...dummy...>, (<type 'object'>,), 1, None)

Calling a ``Method`` invokes the wrapped body::

    >>> meth(1,2,x=3)
    called with (1, 2) {'x': 3}

One ``Method`` implies another if and only if its signature implies the
other's::

    >>> implies(Method(dummy,(int,int)), Method(dummy,(object,object)))
    True

    >>> implies(Method(dummy,(object,object)), Method(dummy,(int,int)))
    False


When a method overrides another, you get the overriding method::

    >>> meth.override(Method(dummy))
    Method(<...dummy...>, (<type 'object'>,), 1, None)

Unless the overriding method's body is a function whose first parameter is
named ``next_method``, in which case a chain of methods is created via the
"tail" of a copy of the overriding method::

    >>> def overriding_fn(next_method, etc):
    ...     print "calling", next_method
    ...     return next_method(etc)

    >>> chain = Method(overriding_fn).override(Method(dummy))
    >>> chain
    Method(<...overriding_fn...>, (), 0, Method(<...dummy...>, (), 0, None))

The resulting chain is a callable ``Method``, and the ``next_method`` is passed
in to the first function of the chain::

    >>> chain(42)
    calling Method(<...dummy...>, (), 0, None)
    called with (42,) {}


Around
------

``Around`` methods are identical to normal ``Method`` objects, except that
whenever an ``Around`` method and a regular ``Method`` are combined, the
``Around`` method overrides the regular one.  This forces all the regular
methods to be further down the chain than all of the "around" methods.

    >>> from peak.rules.framework import Around

    >>> combine_actions(Method(dummy), Around(overriding_fn))
    Around(<...overriding_fn...>, (), 0, Method(<...dummy...>, (), 0, None))

You will normally only want to use ``Around`` methods with functions that have
a ``next_method`` parameter, since their purpose is to wrap "around" the
calling of lower-precedence methods.  If you don't do this, then the method
chain will always end at that ``Around`` instance::

    >>> combine_actions(Method(overriding_fn), Around(dummy))
    Around(<...dummy...>, (), 0, None)


NoApplicableMethods
-------------------

The simplest possible action type is ``NoApplicableMethods``, meaning that
there is no applicable action.  When it's overridden by another method, it
will of course get chained to the other method's tail (if appropriate).

    >>> from peak.rules.framework import NoApplicableMethods
    >>> naf = NoApplicableMethods()
    >>> meth = Method(overriding_fn)

    >>> combine_actions(naf, meth)
    Method(<...overriding_fn...>, (), 0, <...NoApplicableMethods...>)

    >>> combine_actions(meth, naf)
    Method(<...overriding_fn...>, (), 0, <...NoApplicableMethods...>)

Calling a ``NoApplicableMethods`` raises it, displaying the arguments it was
called with::

    >>> naf(1,2,x="y")
    Traceback (most recent call last):
      ...
    NoApplicableMethods: ((1, 2), {'x': 'y'})


Before and After
----------------

The ``Before`` and ``After`` action types are used to call observers before
or after invoking a chained action.


MethodList, Before, After,



AmbiguousMethods
-----------------



decorators and how to create them: when, around, before, after

custom combination demo from RuleDispatch (compute upcharges+tax)


Core Algorithm
==============

combine_actions(a1, a2)

compile_action(engine, action)



----------------
Rules Management
----------------

Rule Objects
============

Rule objects are essentially pure data objects, pairing a predicate, a body,
and an action type that will be used as a factory to create the actions for the
rule.  At minimum, all a rule needs is a body.  The predicate and action type
both default to ``None`` if not specified::

    >>> from peak.rules.framework import Rule
    >>> def dummy(): pass
    >>> r = Rule(dummy)
    >>> r
    Rule(<function dummy ...>, (), None)

An action type of ``None`` (or any false value) means that the ruleset should
decide what action type to use.  Actually, it can decide anyway, since the
rule set is always responsible for creating action objects; the rule's action
type is really just advisory to begin with.


RuleSet
=======

``RuleSet`` objects hold the rules and policy information for a generic
function, including the default action type and optional optimziation hints.

Iterating over a ruleset yields its actions::

    >>> from peak.rules.framework import RuleSet
    >>> rs = RuleSet()
    >>> list(rs)
    []

And rules can be added and removed with the ``add()`` and ``remove()``
methods::

    >>> r = Rule(dummy)
    >>> rs.add(r)
    >>> list(rs)
    [(<...Method...>, <function dummy ...>, (), 0)]

    >>> rs.remove(r)
    >>> list(rs)
    []

Observers can be added with the ``subscribe()`` and ``unsubscribe()`` methods.
Observers have their ``actions_changed`` method called with an "added" set
and a "removed" set of action definitions.  (An action definition is a
tuple of the form ``(actiontype, body, signature, precedence)``, and can thus
be used to create action objects.)

::

    >>> class DummyObserver:
    ...     def actions_changed(self, added, removed):
    ...         for a in added: print "Add:", a
    ...         for a in removed: print "Remove:", a
    >>> do = DummyObserver()

    >>> rs.subscribe(do)

    >>> rs.add(r)
    Add: (<...Method...>, <function dummy ...>, (), 1)

    >>> rs.remove(r)
    Remove: (<...Method...>, <function dummy ...>, (), 1)

    >>> rs.unsubscribe(do)

When an observer is first added, it's notified of the current contents of the
``RuleSet``, if any.  As a result, observers don't need to do any special case
handling for their initial setup.  Everything can be handled via the normal
operation of the ``actions_changed()`` method::

    >>> rs.add(r)
    >>> rs.subscribe(do)
    Add: (<...Method...>, <function dummy ...>, (), 2)

Unsubscribing, however, does not send any removal messages::

    >>> rs.unsubscribe(do)




-------------
Miscellaneous
-------------

Subscription Management
=======================


