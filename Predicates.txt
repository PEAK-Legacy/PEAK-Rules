==================
Predicate Dispatch
==================


Predicate Expression Types
==========================

Predicate expression types wrap expressions to specify what kind of dispatching
should be done on the base expression.  For example,  ``predicates.IsInstance``
indicates that an expression is to be looked up by what it's an instance of.

There are five built-in expression types::

    >>> from peak.rules.predicates import \
    ...     Truth, Identity, Comparison, IsSubclass, IsInstance

And we will test them using code objects:

    >>> from peak.util.assembler import Code, Const
    >>> from dis import dis
    
Truth
-----

The ``Truth`` predicate tests whether its subject expression is true or false,
and selects the appropriate sub-node from a ``(true_node, false_node)`` tuple::

    >>> c = Code()
    >>> c(Truth(42))
    >>> dis(c.code())
      0           0 LOAD_FAST                0 ($Arg)
                  3 UNPACK_SEQUENCE          2
                  6 LOAD_CONST               1 (42)
                  9 JUMP_IF_TRUE             1 (to 13)
                 12 ROT_THREE
            >>   13 POP_TOP
                 14 ROT_TWO
                 15 POP_TOP

The generated code unpacks the 2-tuple, and then does a bit of stack
manipulation to select the correct subnode.

                 
Identity
--------

The ``Identity`` predicate looks up the ``id()`` of its subject expression in
a dictionary of sub-nodes.  If the id isn't found, the ``None`` entry is used::

    >>> c = Code()
    >>> c(Identity(99))
    >>> dis(c.code())
      0           0 LOAD_CONST               1 (<built-in function id>)
                  3 LOAD_CONST               2 (99)
                  6 CALL_FUNCTION            1
                  9 DUP_TOP
                 10 LOAD_FAST                0 ($Arg)
                 13 COMPARE_OP               6 (in)
                 16 JUMP_IF_FALSE            9 (to 28)
                 19 POP_TOP
                 20 LOAD_FAST                0 ($Arg)
                 23 ROT_TWO
                 24 BINARY_SUBSCR
                 25 JUMP_FORWARD             9 (to 37)
            >>   28 POP_TOP
                 29 POP_TOP
                 30 LOAD_FAST                0 ($Arg)
                 33 LOAD_CONST               0 (None)
                 36 BINARY_SUBSCR


Comparison
----------

The ``Comparison`` predicate expects its "arg" to be an ``(exact, ranges)``
pair, such as might be generated by the ``peak.rules.indexing.split_ranges``
function::

    >>> c = Code()
    >>> c(Comparison(555))
    >>> dis(c.code())
      0           0 LOAD_CONST               1 (<function value_check at ...>)
                  3 LOAD_CONST               2 (555)
                  6 LOAD_FAST                0 ($Arg)
                  9 CALL_FUNCTION            2

The generated code simply calls a helper function, ``value_check``, with its
expression and argument.  The helper function looks up and returns the
appropriate subnode, first by trying for an exact match, and then looking for
a range match if no exact match is found::

    >>> from peak.rules.predicates import value_check
    >>> from peak.util.extremes import Min, Max

    >>> exact = {'x':1, 'y':2}
    >>> ranges = [((Min,'x'),42), (('x','y'),99), (('y',Max),88)]

    >>> for letter in 'wxyz':
    ...     print value_check(letter, (exact, ranges))
    42
    1
    2
    88
    >>> value_check('xx', (exact, ranges))
    99


IsSubclass
----------

The ``IsSubclass`` predicate uses a ``(cache, lookup)`` node pair, where
`cache` is a dictionary from classes to nodes, and `lookup` is a function to
call with the class, in the event that the target class isn't found in the
cache::

    >>> c = Code()
    >>> c(IsSubclass(Const(int)))
    >>> dis(c.code())
      0           0 LOAD_CONST               1 (<type 'int'>)
                  3 SETUP_EXCEPT            16 (to 22)
                  6 DUP_TOP
                  7 LOAD_FAST                0 ($Arg)
                 10 UNPACK_SEQUENCE          2
                 13 ROT_THREE
                 14 POP_TOP
                 15 BINARY_SUBSCR
                 16 ROT_TWO
                 17 POP_TOP
                 18 POP_BLOCK
                 19 JUMP_FORWARD            30 (to 52)
            >>   22 DUP_TOP
                 23 LOAD_CONST               2 (<...KeyError...>)
                 26 COMPARE_OP              10 (exception match)
                 29 JUMP_IF_FALSE           18 (to 50)
                 32 POP_TOP
                 33 POP_TOP
                 34 POP_TOP
                 35 POP_TOP
                 36 LOAD_FAST                0 ($Arg)
                 39 UNPACK_SEQUENCE          2
                 42 POP_TOP
                 43 ROT_TWO
                 44 CALL_FUNCTION            1
                 47 JUMP_FORWARD             2 (to 52)
            >>   50 POP_TOP
                 51 END_FINALLY
                 

IsInstance
----------

The ``IsInstance`` predicate is virtually identical to ``IsSubclass``, except
that it first obtains the ``__class__`` or ``type()`` of its target::

    >>> c = Code()
    >>> c(IsInstance(Const(999)))
    >>> dis(c.code())
      0           0 LOAD_CONST               1 (999)
                  3 SETUP_EXCEPT            10 (to 16)
                  6 DUP_TOP
                  7 LOAD_ATTR                0 (__class__)
                 10 ROT_TWO
                 11 POP_TOP
                 12 POP_BLOCK
                 13 JUMP_FORWARD            26 (to 42)
            >>   16 DUP_TOP
                 17 LOAD_CONST               2 (<...AttributeError...>)
                 20 COMPARE_OP              10 (exception match)
                 23 JUMP_IF_FALSE           14 (to 40)
                 26 POP_TOP
                 27 POP_TOP
                 28 POP_TOP
                 29 POP_TOP
                 30 LOAD_CONST               3 (<type 'type'>)
                 33 ROT_TWO
                 34 CALL_FUNCTION            1
                 37 JUMP_FORWARD             2 (to 42)
            >>   40 POP_TOP
                 41 END_FINALLY
            >>   42 SETUP_EXCEPT            16 (to 61)
                 45 DUP_TOP
                 46 LOAD_FAST                0 ($Arg)
                 49 UNPACK_SEQUENCE          2
                 52 ROT_THREE
                 53 POP_TOP
                 54 BINARY_SUBSCR
                 55 ROT_TWO
                 56 POP_TOP
                 57 POP_BLOCK
                 58 JUMP_FORWARD            30 (to 91)
            >>   61 DUP_TOP
                 62 LOAD_CONST               4 (<...KeyError...>)
                 65 COMPARE_OP              10 (exception match)
                 68 JUMP_IF_FALSE           18 (to 89)
                 71 POP_TOP
                 72 POP_TOP
                 73 POP_TOP
                 74 POP_TOP
                 75 LOAD_FAST                0 ($Arg)
                 78 UNPACK_SEQUENCE          2
                 81 POP_TOP
                 82 ROT_TWO
                 83 CALL_FUNCTION            1
                 86 JUMP_FORWARD             2 (to 91)
            >>   89 POP_TOP
                 90 END_FINALLY


Defining New Expression Types
-----------------------------

A predicate type must be a ``peak.util.assembler.nodetype``, capable of
generating its own lookup code.  The code will be used in a ``SMIGenerator``
context (see the `Code Generation`_ manual), so ``SMIGenerator.ARG`` will
contain a lookup node.

Each predicate type must be usable with the ``predicates.predicate_node_for``
function:

predicate_node_for(builder, expr, cases, remaining_exprs, memo)
    Return a dispatch tree node argument appropriate for the expr.

The return value(s) of this method will be in the ``SMIGenerator.ARG`` local
variable when the predicate type's bytecode is executed.

