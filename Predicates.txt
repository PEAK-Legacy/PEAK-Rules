==================
Predicate Dispatch
==================


Predicate Expression Types
==========================

Predicate expression types wrap expressions to specify what kind of dispatching
should be done on the base expression.  For example,  ``predicates.IsInstance``
indicates that an expression is to be looked up by what it's an instance of.

There are five built-in expression types::

    >>> from peak.rules.predicates import \
    ...     Truth, Identity, Comparison, IsSubclass, IsInstance

And we will test them using code objects:

    >>> from peak.util.assembler import Code, Const
    >>> from dis import dis

Truth
-----

The ``Truth`` predicate tests whether its subject expression is true or false,
and selects the appropriate sub-node from a ``(true_node, false_node)`` tuple::

    >>> c = Code()
    >>> c(Truth(42))
    >>> dis(c.code())
      0           0 LOAD_FAST                0 ($Arg)
                  3 UNPACK_SEQUENCE          2
                  6 LOAD_CONST               1 (42)
                  9 JUMP_IF_TRUE             1 (to 13)
                 12 ROT_THREE
            >>   13 POP_TOP
                 14 ROT_TWO
                 15 POP_TOP

The generated code unpacks the 2-tuple, and then does a bit of stack
manipulation to select the correct subnode.

The ``disjuncts()`` of a Truth Test (or Truth Signature) are the Test itself::

    >>> from peak.rules import disjuncts
    >>> from peak.rules.criteria import Test, Signature

    >>> disjuncts(Test(Truth(88), True))
    [Test(Truth(88), True)]

    >>> disjuncts(Test(Truth(88), False))
    [Test(Truth(88), False)]

    >>> Signature([Test(Truth(99), True), Test(Truth(88), False)])

(These proofs are needed a ``Test`` of a non-``Truth`` expression with
boolean value would ordinarily have different disjuncts.)


Identity
--------

The ``Identity`` predicate looks up the ``id()`` of its subject expression in
a dictionary of sub-nodes.  If the id isn't found, the ``None`` entry is used::

    >>> c = Code()
    >>> c(Identity(99))
    >>> dis(c.code())
      0           0 LOAD_CONST               1 (<built-in function id>)
                  3 LOAD_CONST               2 (99)
                  6 CALL_FUNCTION            1
                  9 DUP_TOP
                 10 LOAD_FAST                0 ($Arg)
                 13 COMPARE_OP               6 (in)
                 16 JUMP_IF_FALSE            9 (to 28)
                 19 POP_TOP
                 20 LOAD_FAST                0 ($Arg)
                 23 ROT_TWO
                 24 BINARY_SUBSCR
                 25 JUMP_FORWARD             9 (to 37)
            >>   28 POP_TOP
                 29 POP_TOP
                 30 LOAD_FAST                0 ($Arg)
                 33 LOAD_CONST               0 (None)
                 36 BINARY_SUBSCR


Comparison
----------

The ``Comparison`` predicate expects its "arg" to be an ``(exact, ranges)``
pair, such as might be generated by the ``peak.rules.indexing.split_ranges``
function::

    >>> c = Code()
    >>> c(Comparison(555))
    >>> dis(c.code())
      0           0 LOAD_CONST               1 (<function value_check at ...>)
                  3 LOAD_CONST               2 (555)
                  6 LOAD_FAST                0 ($Arg)
                  9 CALL_FUNCTION            2

The generated code simply calls a helper function, ``value_check``, with its
expression and argument.  The helper function looks up and returns the
appropriate subnode, first by trying for an exact match, and then looking for
a range match if no exact match is found::

    >>> from peak.rules.predicates import value_check
    >>> from peak.util.extremes import Min, Max

    >>> exact = {'x':1, 'y':2}
    >>> ranges = [((Min,'x'),42), (('x','y'),99), (('y',Max),88)]

    >>> for letter in 'wxyz':
    ...     print value_check(letter, (exact, ranges))
    42
    1
    2
    88
    >>> value_check('xx', (exact, ranges))
    99


IsSubclass
----------

The ``IsSubclass`` predicate uses a ``(cache, lookup)`` node pair, where
`cache` is a dictionary from classes to nodes, and `lookup` is a function to
call with the class, in the event that the target class isn't found in the
cache::

    >>> c = Code()
    >>> c(IsSubclass(Const(int)))
    >>> dis(c.code())
      0           0 LOAD_CONST               1 (<type 'int'>)
                  3 SETUP_EXCEPT            16 (to 22)
                  6 DUP_TOP
                  7 LOAD_FAST                0 ($Arg)
                 10 UNPACK_SEQUENCE          2
                 13 ROT_THREE
                 14 POP_TOP
                 15 BINARY_SUBSCR
                 16 ROT_TWO
                 17 POP_TOP
                 18 POP_BLOCK
                 19 JUMP_FORWARD            30 (to 52)
            >>   22 DUP_TOP
                 23 LOAD_CONST               2 (<...KeyError...>)
                 26 COMPARE_OP              10 (exception match)
                 29 JUMP_IF_FALSE           18 (to 50)
                 32 POP_TOP
                 33 POP_TOP
                 34 POP_TOP
                 35 POP_TOP
                 36 LOAD_FAST                0 ($Arg)
                 39 UNPACK_SEQUENCE          2
                 42 POP_TOP
                 43 ROT_TWO
                 44 CALL_FUNCTION            1
                 47 JUMP_FORWARD             2 (to 52)
            >>   50 POP_TOP
                 51 END_FINALLY


IsInstance
----------

The ``IsInstance`` predicate is virtually identical to ``IsSubclass``, except
that it first obtains the ``__class__`` or ``type()`` of its target::

    >>> c = Code()
    >>> c(IsInstance(Const(999)))
    >>> dis(c.code())
      0           0 LOAD_CONST               1 (999)
                  3 SETUP_EXCEPT            10 (to 16)
                  6 DUP_TOP
                  7 LOAD_ATTR                0 (__class__)
                 10 ROT_TWO
                 11 POP_TOP
                 12 POP_BLOCK
                 13 JUMP_FORWARD            26 (to 42)
            >>   16 DUP_TOP
                 17 LOAD_CONST               2 (<...AttributeError...>)
                 20 COMPARE_OP              10 (exception match)
                 23 JUMP_IF_FALSE           14 (to 40)
                 26 POP_TOP
                 27 POP_TOP
                 28 POP_TOP
                 29 POP_TOP
                 30 LOAD_CONST               3 (<type 'type'>)
                 33 ROT_TWO
                 34 CALL_FUNCTION            1
                 37 JUMP_FORWARD             2 (to 42)
            >>   40 POP_TOP
                 41 END_FINALLY
            >>   42 SETUP_EXCEPT            16 (to 61)
                 45 DUP_TOP
                 46 LOAD_FAST                0 ($Arg)
                 49 UNPACK_SEQUENCE          2
                 52 ROT_THREE
                 53 POP_TOP
                 54 BINARY_SUBSCR
                 55 ROT_TWO
                 56 POP_TOP
                 57 POP_BLOCK
                 58 JUMP_FORWARD            30 (to 91)
            >>   61 DUP_TOP
                 62 LOAD_CONST               4 (<...KeyError...>)
                 65 COMPARE_OP              10 (exception match)
                 68 JUMP_IF_FALSE           18 (to 89)
                 71 POP_TOP
                 72 POP_TOP
                 73 POP_TOP
                 74 POP_TOP
                 75 LOAD_FAST                0 ($Arg)
                 78 UNPACK_SEQUENCE          2
                 81 POP_TOP
                 82 ROT_TWO
                 83 CALL_FUNCTION            1
                 86 JUMP_FORWARD             2 (to 91)
            >>   89 POP_TOP
                 90 END_FINALLY


Defining New Predicate Types
-----------------------------

A predicate type must be a ``peak.util.assembler.nodetype``, capable of
generating its own lookup code.  The code will be used in a ``SMIGenerator``
context (see the `Code Generation`_ manual), so ``SMIGenerator.ARG`` will
contain a lookup node.

Each predicate type must be usable with the ``predicates.predicate_node_for``
function, and the ``predicates.always_testable`` function:

predicate_node_for(builder, expr, cases, remaining_exprs, memo)
    Return a dispatch tree node argument appropriate for the expr.  The return
    value(s) of this function will be in the ``SMIGenerator.ARG`` local
    variable when the predicate type's bytecode is executed.

always_testable(expr)
    Return true if the expression can always be tested, regardless of its
    position among the signature condition(s).  Most predicate types should
    just implement this by calling ``always_testable()`` recursively on their
    target expression, and in fact all of the built-in predicate types do this.
    For more details, see the section on `Order Independence`_ below.


Predicate Parsing
=================

The ``CriteriaBuilder`` class can be used to parse Python expressions into
tests and signatures.  It's initialized using the same arguments as the
``codegen.ExprBuilder`` class::

    >>> from peak.rules.predicates import CriteriaBuilder, Comparison
    >>> from peak.rules.criteria import Disjunction, Value, Test, Range, Class
    >>> from peak.util.assembler import Local

    >>> builder = CriteriaBuilder(
    ...     dict(x=Local('x'), y=Local('y')), locals(), globals(), __builtins__
    ... )
    >>> from peak.rules.ast_builder import parse_expr
    >>> def pe(expr):
    ...     return parse_expr(expr, builder)

    >>> pe('x+42 > 23*2')
    Test(Comparison(Add(Local('x'), Const(42))), Range((46, 1), (Max, 1)))


The ``in`` operator converts constant classes into ``IsInstance`` tests::

    >>> pe('x in int')
    Test(IsInstance(Local('x')), Class(<type 'int'>, True))

    >>> pe('x not in int')
    Test(IsInstance(Local('x')), Class(<type 'int'>, False))

Iterable constants into or-ed equality tests::

    >>> pe('x in (1,2,3)') == Disjunction([
    ...     Test(Comparison(Local('x')), Value(2, True)),
    ...     Test(Comparison(Local('x')), Value(3, True)),
    ...     Test(Comparison(Local('x')), Value(1, True))
    ... ])
    True

    >>> pe('x not in (1,2,3)') == Test( Comparison(Local('x')), Disjunction([
    ...     Range((Min, -1), (1, -1)), Range((1, 1), (2, -1))])
    ... )
    True

And non-iterable constants into plain expressions::

    >>> pe('x in 27')
    Test(Truth(Compare(Local('x'), (('in', Const(27)),))), True)

    >>> pe('x not in 27')
    Test(Truth(Compare(Local('x'), (('not in', Const(27)),))), True)


The ``is`` operator produces identity tests, if either side is a constant::

    >>> pe('x is 42')
    Test(Identity(Local('x')), IsObject(42, True))

    >>> pe('42 is not x')
    Test(Identity(Local('x')), IsObject(42, False))


And plain expressions when neither side is constant::

    >>> pe('x is y')
    Test(Truth(Compare(Local('x'), (('is', Local('y')),))), True)

    >>> pe('x is not y')
    Test(Truth(Compare(Local('x'), (('is not', Local('y')),))), True)

    >>> pe('not (x is y)')
    Test(Truth(Compare(Local('x'), (('is', Local('y')),))), False)

    >>> pe('not (x is not y)')
    Test(Truth(Compare(Local('x'), (('is not', Local('y')),))), False)


Complex logical expressions are always rendered in disjunctive normal form,
with negations simplified away or reduced to match flags on criteria objects::

    >>> pe('x in int and y in str')
    Signature([Test(IsInstance(Local('x')), Class(<type 'int'>, True)),
               Test(IsInstance(Local('y')), Class(<type 'str'>, True))])

    >>> pe('not(x not in int or y not in str)')
    Signature([Test(IsInstance(Local('x')), Class(<type 'int'>, True)),
               Test(IsInstance(Local('y')), Class(<type 'str'>, True))])


    >>> pe('x in int and (y in str or y in unicode)')
    Disjunction([Signature([Test(IsInstance(Local('x')),
                                 Class(<type 'int'>, True)),
                            Test(IsInstance(Local('y')),
                                 Class(<type 'str'>, True))]),
                 Signature([Test(IsInstance(Local('x')),
                                 Class(<type 'int'>, True)),
                            Test(IsInstance(Local('y')),
                                 Class(<type 'unicode'>, True))])])

    >>> pe('not (x in int or y in str)')
    Signature([Test(IsInstance(Local('x')), Class(<type 'int'>, False)),
               Test(IsInstance(Local('y')), Class(<type 'str'>, False))])

    >>> pe('not( x not in int and y not in str)') == Disjunction([
    ...     Test(IsInstance(Local('x')), Class(int)),
    ...     Test(IsInstance(Local('y')), Class(str))
    ... ])
    True

    >>> pe('not( x in int and y in str)')
    Disjunction([Test(IsInstance(Local('y')), Class(<type 'str'>, False)),
                 Test(IsInstance(Local('x')), Class(<type 'int'>, False))])


And arbitrary expressions are handled as truth tests::

    >>> pe('x')
    Test(Truth(Local('x')), True)

    >>> pe('not x')
    Test(Truth(Local('x')), False)


Pattern Matching
----------------

Arbitrary expressions can be pattern matched for conversion into signatures.
At the moment, the only patterns matched are ``isinstance`` and ``issubclass``
calls where the second argument is a constant::

    >>> from peak.rules.criteria import Test, Signature, Classes

    >>> pe('isinstance(x,int)')
    Test(IsInstance(Local('x')), Class(<type 'int'>, True))

    >>> pe('isinstance(x,(str,unicode))') == Disjunction([
    ...     Test(IsInstance(Local('x')), Class(str)),
    ...     Test(IsInstance(Local('x')), Class(unicode))
    ... ])
    True

    >>> pe('not isinstance(x,(int,(str,unicode)))') == Test(
    ...     IsInstance(Local('x')), Classes([
    ...         Class(unicode, False), Class(int, False), Class(str, False)])
    ... )
    True

    >>> pe('isinstance(x,(int,(str,unicode)))') == Disjunction([
    ...     Test(IsInstance(Local('x')), Class(str)),
    ...     Test(IsInstance(Local('x')), Class(int)),
    ...     Test(IsInstance(Local('x')), Class(unicode))
    ... ])
    True

    >>> pe('issubclass(x,int)')
    Test(IsSubclass(Local('x')), Class(<type 'int'>, True))

    >>> pe('issubclass(x,(str,unicode))') == Disjunction([
    ...     Test(IsSubclass(Local('x')), Class(str)),
    ...     Test(IsSubclass(Local('x')), Class(unicode))
    ... ])
    True

    >>> pe('issubclass(x,(int,(str,unicode)))') == Disjunction([
    ...     Test(IsSubclass(Local('x')), Class(str)),
    ...     Test(IsSubclass(Local('x')), Class(int)),
    ...     Test(IsSubclass(Local('x')), Class(unicode))
    ... ])
    True

    >>> pe('not issubclass(x,(int,(str,unicode)))') == Test(
    ...     IsSubclass(Local('x')), Classes([
    ...         Class(unicode, False), Class(int, False), Class(str, False)])
    ... )
    True


Upgrading from ``TypeEngine``
=============================

In order to allow a function to safely upgrade from type-only dispatch to full
predicate dispatch, it's necessary for predicate engines to support using type
tuples as signatures (since such tuples may already be registered with the
function's ``RuleSet``).

To support this, the ``tests_for()`` function takes an optional second
parameter, representing the engine that "wants" the tests, and whose argument
names will be used to accomplish the conversion::

    >>> from peak.rules.core import Dispatching, istype, implies
    >>> from peak.rules.criteria import tests_for
    >>> engine = Dispatching(implies).engine

    >>> list(tests_for((int,str), engine))
    [Test(IsInstance(Local('s1')), Class(<type 'int'>, True)),
     Test(IsInstance(Local('s2')), Class(<type 'str'>, True))]

    >>> list(tests_for((istype(tuple),), engine))
    [Test(IsInstance(Local('s1')), istype(<type 'tuple'>, True))]

Each element of the type tuple is converted using a second generic function,
``type_to_test``::

    >>> from peak.rules.predicates import type_to_test

    >>> type_to_test(int, Local('x'), engine)
    Test(IsInstance(Local('x')), Class(<type 'int'>, True))

    >>> type_to_test(istype(str), Local('x'), engine)
    Test(IsInstance(Local('x')), istype(<type 'str'>, True))

    >>> class x: pass
    >>> type_to_test(x, Local('x'), engine)
    Test(IsInstance(Local('x')), Class(<class ...x at ...>, True))

If you implement a new kind of class test for use in type tuples, you'll need
to add the appropriate method(s) to ``type_to_test`` if you want it to also
work with the predicate engine.


Criterion Ordering
==================

Criterion ordering for a predicate dispatch engine is defined by the ordering
of the tests in its signatures.  Any test expression that is not defined as
``always_testable``, must not be computed until after any test expressions
to its left have been tested.  But tests whose expression is just a local
variable (i.e., a plain function argument), do not have such restrictions::

    >>> from peak.rules.predicates import IndexedEngine
    >>> from peak.rules import abstract, when
    >>> from peak.rules.indexing import Ordering
    >>> from peak.rules.codegen import Add

    >>> def f(a,b): pass
    >>> f = abstract(f)
    >>> m = when(f, "isinstance(a, int) and a+b==42")(lambda a,b: None)
    >>> engine = Dispatching(f).engine
    >>> list(Ordering(engine, IsInstance(Local('a'))).constraints)
    [frozenset([])]
    >>> list(Ordering(engine, Comparison(Add(Local('a'),Local('b')))).constraints)
    [frozenset([IsInstance(Local('a'))])]


    >>> def f(a,b): pass
    >>> f = abstract(f)
    >>> m = when(f, "isinstance(b, str) and a+b==42 and isinstance(a, int)")(
    ...     lambda a,b: None
    ... )
    >>> engine = Dispatching(f).engine
    >>> list(Ordering(engine, IsInstance(Local('a'))).constraints)
    [frozenset([])]
    >>> list(Ordering(engine, IsInstance(Local('b'))).constraints)
    [frozenset([])]
    >>> list(Ordering(engine, Comparison(Add(Local('a'),Local('b')))).constraints)
    [frozenset([IsInstance(Local('b'))])]

    >>> def f(a,b): pass
    >>> f = abstract(f)
    >>> m = when(f, "isinstance(a, int) and isinstance(b, str) and a+b==42")(
    ...     lambda a,b: None
    ... )
    >>> engine = Dispatching(f).engine
    >>> list(Ordering(engine, IsInstance(Local('a'))).constraints)
    [frozenset([])]
    >>> list(Ordering(engine, IsInstance(Local('b'))).constraints)
    [frozenset([])]
    >>> list(Ordering(engine, Comparison(Add(Local('a'),Local('b')))).constraints)
    [frozenset([IsInstance(Local('a')), IsInstance(Local('b'))])]


Order Independence
------------------

The determination of whether a test expression can be used in an order-
independent way, is via the ``always_testable()`` function::

    >>> from peak.rules.predicates import always_testable

In general, only locals and constants can have their tests applied independent
of signature ordering::

    >>> always_testable(Local('x'))
    True

    >>> always_testable(Const(99))
    True

    >>> always_testable(Add(Local('a'),Local('b')))
    False

And predicate test expressions are evaluated according to their tested
expression::

    >>> always_testable(IsInstance(Local('x')))
    True
    >>> always_testable(IsInstance(Add(Local('a'),Local('b'))))
    False

    >>> always_testable(IsSubclass(Local('x')))
    True
    >>> always_testable(IsSubclass(Add(Local('a'),Local('b'))))
    False

    >>> always_testable(Comparison(Local('x')))
    True
    >>> always_testable(Comparison(Add(Local('a'),Local('b'))))
    False

    >>> always_testable(Identity(Local('x')))
    True
    >>> always_testable(Identity(Add(Local('a'),Local('b'))))
    False

    >>> always_testable(Truth(Local('x')))
    True
    >>> always_testable(Truth(Add(Local('a'),Local('b'))))
    False

If you create a new predicate type, be sure to define a method for
``always_testable`` that will recursively invoke ``always_testable`` on the
predicate's target expression.  If you don't do this, then your predicate
type will always be treated as order-dependent, even if its target expression
is a local or constant.

