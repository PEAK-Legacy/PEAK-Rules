========================================
Code Generation from Python Syntax Trees
========================================

The ``peak.rules.codegen`` module extends ``peak.util.assembler`` (from the
"BytecodeAssembler" project) with additional AST node types to allow generation
of code for simple Python expressions (i.e., those without lambdas,
comprehensions, generators, or conditionals).  It also provides "builder"
classes that work with the ``peak.rules.ast_builder`` module to generate
expression ASTs from Python source code, thus creating an end-to-end compiler
tool chain.

This document describes the design (and tests the implementation) of the
``codegen`` module.  You don't need to read it unless you want to use
this module directly in your own programs.  If you do want to use it directly,
keep in mind that it inherits the limitations and restrictions of both
``peak.util.assembler`` and ``peak.rules.ast_builder``, so you should consult
the documentation for those tools before proceeding.


--------------
AST Generation
--------------

To generate an AST from Python code, you need the ``ast_builder.parse_expr()``
function, and the ``codegen.ExprBuilder`` type::

    >>> from peak.rules.ast_builder import parse_expr
    >>> from peak.rules.codegen import ExprBuilder

``ExprBuilder`` instances are created using one or more namespaces.  The first
namespace maps names to arbitrary AST nodes that will be substituted for any
matching names found in an expression.  The second and remaining namespaces
will have their values wrapped in ``Const`` nodes, so they can be used for
constant-folding.  For our examples, we'll define a base namespace containing
arguments named "a" through "g"::

    >>> from peak.util.assembler import Local
    >>> argmap = dict([(name,Local(name)) for name in 'abcdefg'])
    >>> builder = ExprBuilder(argmap, locals(), globals(), __builtins__)

And, for convenience, we'll define a short function to parse and output an
expression's AST using this builder instance::

    >>> def pe(expr):
    ...     print parse_expr(expr, builder)


Names and Constants
===================

Constants are wrapped in BytecodeAsssembler ``Const()`` nodes::

    >>> pe("1")
    Const(1)

Names found in the first namespace are mapped to whatever value is in the
namespace::

    >>> pe("a")
    Local('a')

Names found in subsequent namespaces get their values wrapped in ``Const()``
nodes::

    >>> pe("ExprBuilder")
    Const(<...peak.rules.codegen.ExprBuilder...>)

    >>> pe("isinstance")
    Const(<built-in function isinstance>)

And unfound names produce a compile-time error::

    >>> pe("fubar")
    Traceback (most recent call last):
      ...
    NameError: fubar


Operators
=========

Unary operators::

    >>> pe("not - + ~ `a`")
    Not(Minus(Plus(Invert(Repr(Local('a'))))))


Attribute access::

    >>> pe("a.b.c")
    Getattr(Getattr(Local('a'), 'b'), 'c')


Simple binary operators::

    >>> pe("a+b")
    Add(Local('a'), Local('b'))
    >>> pe("b-a")
    Sub(Local('b'), Local('a'))
    >>> pe("c*d")
    Mul(Local('c'), Local('d'))
    >>> pe("c/d")
    Div(Local('c'), Local('d'))
    >>> pe("c%d")
    Mod(Local('c'), Local('d'))
    >>> pe("c//d")
    FloorDiv(Local('c'), Local('d'))

    >>> pe("a**b")
    Power(Local('a'), Local('b'))
    >>> pe("a<<b")
    LeftShift(Local('a'), Local('b'))
    >>> pe("a>>b")
    RightShift(Local('a'), Local('b'))

    >>> pe("a[1]")
    Getitem(Local('a'), Const(1))
    >>> pe("a[1][2]")
    Getitem(Getitem(Local('a'), Const(1)), Const(2))

    >>> pe("a&b&c")
    Bitand(Bitand(Local('a'), Local('b')), Local('c'))
    >>> pe("a|b|c")
    Bitor(Bitor(Local('a'), Local('b')), Local('c'))
    >>> pe("a^b^c")
    Bitxor(Bitxor(Local('a'), Local('b')), Local('c'))

List operators::

    >>> pe("a and b")
    And((Local('a'), Local('b')))

    >>> pe("a or b")
    Or((Local('a'), Local('b')))

    >>> pe("a and b and c")
    And((Local('a'), Local('b'), Local('c')))

    >>> pe("a or b or c")
    Or((Local('a'), Local('b'), Local('c')))

    >>> pe("[]")
    Const([])

    >>> pe("[a]")
    List((Local('a'),))

    >>> pe("[a,b]")
    List((Local('a'), Local('b')))

    >>> pe("()")
    Const(())

    >>> pe("a,")
    Tuple((Local('a'),))

    >>> pe("a,b")
    Tuple((Local('a'), Local('b')))

Slicing::

    >>> pe("a[:]")
    GetSlice(Local('a'), Pass, Pass)

    >>> pe("a[1:2]")
    GetSlice(Local('a'), Const(1), Const(2))

    >>> pe("a[1:]")
    GetSlice(Local('a'), Const(1), Pass)

    >>> pe("a[:2]")
    GetSlice(Local('a'), Pass, Const(2))

    >>> pe("a[::]")
    Getitem(Local('a'), Const(slice(None, None, None)))

    >>> pe("a[1:2:3]")
    Getitem(Local('a'), Const(slice(1, 2, 3)))

    >>> pe("a[b:c:d]")
    Getitem(Local('a'), BuildSlice(Local('b'), Local('c'), Local('d')))


Comparisons::

    >>> pe("a>b")
    Compare(Local('a'), (('>', Local('b')),))
    >>> pe("a>=b")
    Compare(Local('a'), (('>=', Local('b')),))
    >>> pe("a<b")
    Compare(Local('a'), (('<', Local('b')),))
    >>> pe("a<=b")
    Compare(Local('a'), (('<=', Local('b')),))
    >>> pe("a<>b")
    Compare(Local('a'), (('!=', Local('b')),))
    >>> pe("a!=b")
    Compare(Local('a'), (('!=', Local('b')),))
    >>> pe("a==b")
    Compare(Local('a'), (('==', Local('b')),))
    >>> pe("a in b")
    Compare(Local('a'), (('in', Local('b')),))
    >>> pe("a is b")
    Compare(Local('a'), (('is', Local('b')),))
    >>> pe("a not in b")
    Compare(Local('a'), (('not in', Local('b')),))
    >>> pe("a is not b")
    Compare(Local('a'), (('is not', Local('b')),))

    >>> pe("a>=b>c")
    Compare(Local('a'), (('>=', Local('b')), ('>', Local('c'))))


Dictionaries::

    >>> pe("{a:b,c:d}")
    Dict(((Local('a'), Local('b')), (Local('c'), Local('d'))))

Conditional Expressions::

    >>> import sys
    >>> if sys.version>='2.5':
    ...     pe("a if b else c")
    ... else:
    ...     print "IfElse(Local('a'), Local('b'), Local('c'))"
    IfElse(Local('a'), Local('b'), Local('c'))

Calls::

    >>> pe("a()")
    Call(Local('a'), (), (), (), (), True)

    >>> pe("a(1,2)")
    Call(Local('a'), (Const(1), Const(2)), (), (), (), True)

    >>> pe("a(1, b=2)")
    Call(Local('a'), (Const(1),), ((Const('b'), Const(2)),), (), (), True)

    >>> pe("a(*b)")
    Call(Local('a'), (), (), Local('b'), (), True)

    >>> pe("a(**c)")
    Call(Local('a'), (), (), (), Local('c'), True)

    >>> pe("a(*b, **c)")
    Call(Local('a'), (), (), Local('b'), Local('c'), True)


-------------------
Bytecode Generation
-------------------

AST's generated using ``ExprBuilder`` can be used directly with
BytecodeAssembler ``Code`` objects to generate bytecode, complete with
constant-folding.  Note that the node types not demonstrated below (e.g.
``And``, ``Or``, ``Compare``, ``Call``) are not defined by the ``codegen``
module, but instead are imported from ``peak.util.assembler``::

    >>> from peak.rules.codegen import *
    >>> from peak.util.assembler import Const, Pass

    >>> Minus(1), Plus(2), Not(True), Invert(-1), Repr(4)
    (Const(-1), Const(2), Const(False), Const(0), Const('4'))

    >>> Add(1,2), Sub(3,2), Mul(4,5), Div(10,2), Mod(7,3), FloorDiv(7,3)
    (Const(3), Const(1), Const(20), Const(5), Const(1), Const(2))

    >>> Power(2,3), LeftShift(1,4), RightShift(12,2)
    (Const(8), Const(16), Const(3))

    >>> Getitem(Const([1,2]), 1)
    Const(2)

    >>> Bitand(3, 1), Bitor(1,2), Bitxor(3,1)
    (Const(1), Const(3), Const(2))

    >>> Getattr(Const(object), '__class__')
    Const(<type 'type'>)

    >>> Dict([(1,2)])
    Const({1: 2})

    >>> aList = Const([1,2,3,4])

    >>> GetSlice(aList)
    Const([1, 2, 3, 4])
    >>> GetSlice(aList, 1)
    Const([2, 3, 4])
    >>> GetSlice(aList, 1, -1)
    Const([2, 3])
    >>> GetSlice(aList, Pass, -1)
    Const([1, 2, 3])

    >>> BuildSlice(1, 2, 3)
    Const(slice(1, 2, 3))

    >>> BuildSlice(1, 2)
    Const(slice(1, 2, None))

    >>> Tuple([1,2])
    Const((1, 2))

    >>> List([1,2])
    Const([1, 2])

    >>> IfElse(1,2,3)
    Const(1)

    >>> IfElse(1,0,3)
    Const(3)


Subexpression Caching
=====================

The ``peak.rules.codegen`` module includes a common-subexpression caching
extension of ``peak.util.assembler``, used to implement "at most once"
calculation of any intermediate results during rule evaluation.  It works
by setting aside a local variable (``$CSECache``) to hold a dictionary of
temporary values, keyed by strings.

Any time a cached value is needed, the dictionary is checked first.  However,
the local variable is initially set to ``None``, to avoid creating a dictionary
unnecessarily.  In this way, only those portions of the dispatch tree that
require intermediate expression evaluation will incur the cost of creating or
accessing the dictionary.

Note that this caching mechanism is not primarily aimed at improving the
performance of the underlying code, although in some cases it *might* have this
effect.  It is also not aimed at producing compact code; the code it generates
may be an order of magnitude larger than the unadorned code would be!

Rather, the goal is to provide the desired semantics with better performance
than the ``RuleDispatch`` package provides for the same operations.  In
``RuleDispatch``, expressions are calculated using partial functions and a
similar cache dictionary to this one, whereas here the functions are
effectively inlined as Python bytecode.

The ``CSECode`` class replaces the ``assembler.Code`` class::

    >>> from dis import dis

    >>> c = CSECode()
    >>> a, b = Local('a'), Local('b')

    >>> dis(c.code())

And the added ``cache()`` method takes an expression to cache.  If no previous
expressions were cached, a preamble is emitted to initialize the cache::

    >>> c.cache(Add(a,b))
    >>> dis(c.code())
      0           0 LOAD_CONST               0 (None)
                  3 STORE_FAST               0 ($CSECache)

But subsequent ``cache()`` calls of course do not repeat the preamble::

    >>> c.cache(Add(a,b))   # deliberate dupe to verify above only happens once
    >>> dis(c.code())
      0           0 LOAD_CONST               0 (None)
                  3 STORE_FAST               0 ($CSECache)

Generating a cached object results in extra code being added to ensure that
the cache variable is initialized and to retrieve the cached value, if present.
The resulting code looks complex, but each of the possible code paths are
actually fairly short.  The cache keys are the string forms of the cached
expressions, with an added number to ensure uniqueness::

    >>> c.return_(Add(a,b))
    >>> dis(c.code())
      0           0 LOAD_CONST               0 (None)
                  3 STORE_FAST               0 ($CSECache)
                  6 LOAD_FAST                0 ($CSECache)
                  9 JUMP_IF_TRUE             9 (to 21)
                 12 BUILD_MAP                0
                 15 STORE_FAST               0 ($CSECache)
                 18 JUMP_FORWARD            20 (to 41)
            >>   21 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 24 COMPARE_OP               6 (in)
                 27 JUMP_IF_FALSE           11 (to 41)
                 30 POP_TOP
                 31 LOAD_FAST                0 ($CSECache)
                 34 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 37 BINARY_SUBSCR
                 38 JUMP_FORWARD            16 (to 57)
            >>   41 POP_TOP
                 42 LOAD_FAST                1 (a)
                 45 LOAD_FAST                2 (b)
                 48 BINARY_ADD
                 49 DUP_TOP
                 50 LOAD_FAST                0 ($CSECache)
                 53 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 56 STORE_SUBSCR
            >>   57 RETURN_VALUE

While the ``cache()`` method marks an expression as definitely cacheable, the
``maybe_cache()`` method allows the code object to decide for itself whether
the expression should be cached.  Specifically, the given expression and all
its subexpressions are evaluated against a dummy code object, and its tree
structure is examined.  Any non-leaf node that appears as a child of two
or more parents, or twice or more as a child of the same parent, is considered
suitable for caching.

In our first example, the expression ``(a+b)/c*d`` is cached, because it's
passed to ``maybe_cache()`` twice -- once by itself, and once as a child of
``((a+b)/c*d) % 3``::

    >>> a_plus_b = Add(a,b)
    >>> c_times_d = Mul(Local('c'), Local('d'))
    >>> abcd = Div(a_plus_b, c_times_d)
    >>> m3 = Mod(abcd, 3)

    >>> c = CSECode()
    >>> c.maybe_cache(abcd)
    >>> c.maybe_cache(m3)

    >>> c.return_(m3)
    >>> dis(c.code())
      0           0 LOAD_CONST               0 (None)
                  3 STORE_FAST               0 ($CSECache)
                  6 LOAD_FAST                0 ($CSECache)
                  9 JUMP_IF_TRUE             9 (to 21)
                 12 BUILD_MAP                0
                 15 STORE_FAST               0 ($CSECache)
                 18 JUMP_FORWARD            20 (to 41)
            >>   21 LOAD_CONST               1 ("Div(Add(Local('a'), Local('b')), Mul(Local('c'), Local('d'))) #1")
                 24 COMPARE_OP               6 (in)
                 27 JUMP_IF_FALSE           11 (to 41)
                 30 POP_TOP             
                 31 LOAD_FAST                0 ($CSECache)
                 34 LOAD_CONST               1 ("Div(Add(Local('a'), Local('b')), Mul(Local('c'), Local('d'))) #1")
                 37 BINARY_SUBSCR       
                 38 JUMP_FORWARD            24 (to 65)
            >>   41 POP_TOP             
                 42 LOAD_FAST                1 (a)
                 45 LOAD_FAST                2 (b)
                 48 BINARY_ADD          
                 49 LOAD_FAST                3 (c)
                 52 LOAD_FAST                4 (d)
                 55 BINARY_MULTIPLY     
                 56 BINARY_DIVIDE       
                 57 DUP_TOP             
                 58 LOAD_FAST                0 ($CSECache)
                 61 LOAD_CONST               1 ("Div(Add(Local('a'), Local('b')), Mul(Local('c'), Local('d'))) #1")
                 64 STORE_SUBSCR        
            >>   65 LOAD_CONST               2 (3)
                 68 BINARY_MODULO       
                 69 RETURN_VALUE        

In the next example, we compute ``(a+b)*(a+b)`` after inspecting
``(a+b)*(b+a)`` and ``(b+a)*(a+b)`` for recurring sub-expressions.  Naturally,
we detect that ``(a+b)`` is used more than once, so it is cached::

    >>> c = CSECode()
    >>> b_plus_a = Add(b,a)
    >>> ab_2 = Mul(a_plus_b, a_plus_b)
    >>> c.maybe_cache(Mul(b_plus_a, a_plus_b))
    >>> c.maybe_cache(Mul(a_plus_b, b_plus_a))
    >>> c.return_(ab_2)
    >>> dis(c.code())
      0           0 LOAD_CONST               0 (None)
                  3 STORE_FAST               0 ($CSECache)
                  6 LOAD_FAST                0 ($CSECache)
                  9 JUMP_IF_TRUE             9 (to 21)
                 12 BUILD_MAP                0
                 15 STORE_FAST               0 ($CSECache)
                 18 JUMP_FORWARD            20 (to 41)
            >>   21 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 24 COMPARE_OP               6 (in)
                 27 JUMP_IF_FALSE           11 (to 41)
                 30 POP_TOP             
                 31 LOAD_FAST                0 ($CSECache)
                 34 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 37 BINARY_SUBSCR       
                 38 JUMP_FORWARD            16 (to 57)
            >>   41 POP_TOP             
                 42 LOAD_FAST                1 (a)
                 45 LOAD_FAST                2 (b)
                 48 BINARY_ADD          
                 49 DUP_TOP             
                 50 LOAD_FAST                0 ($CSECache)
                 53 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 56 STORE_SUBSCR        
            >>   57 LOAD_FAST                0 ($CSECache)
                 60 JUMP_IF_TRUE             9 (to 72)
                 63 BUILD_MAP                0
                 66 STORE_FAST               0 ($CSECache)
                 69 JUMP_FORWARD            20 (to 92)
            >>   72 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 75 COMPARE_OP               6 (in)
                 78 JUMP_IF_FALSE           11 (to 92)
                 81 POP_TOP             
                 82 LOAD_FAST                0 ($CSECache)
                 85 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 88 BINARY_SUBSCR       
                 89 JUMP_FORWARD            16 (to 108)
            >>   92 POP_TOP             
                 93 LOAD_FAST                1 (a)
                 96 LOAD_FAST                2 (b)
                 99 BINARY_ADD          
                100 DUP_TOP             
                101 LOAD_FAST                0 ($CSECache)
                104 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                107 STORE_SUBSCR        
            >>  108 BINARY_MULTIPLY     
                109 RETURN_VALUE        

And in this example, we also compute ``(a+b)*(a+b)``, but this time only
inspecting that one expression for recurrences.  We still find the recurrence,
because ``(a+b)`` occurs more than once under the parent expression::

    >>> c = CSECode()
    >>> c.maybe_cache(ab_2)
    >>> c.return_(ab_2)
    >>> dis(c.code())
      0           0 LOAD_CONST               0 (None)
                  3 STORE_FAST               0 ($CSECache)
                  6 LOAD_FAST                0 ($CSECache)
                  9 JUMP_IF_TRUE             9 (to 21)
                 12 BUILD_MAP                0
                 15 STORE_FAST               0 ($CSECache)
                 18 JUMP_FORWARD            20 (to 41)
            >>   21 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 24 COMPARE_OP               6 (in)
                 27 JUMP_IF_FALSE           11 (to 41)
                 30 POP_TOP             
                 31 LOAD_FAST                0 ($CSECache)
                 34 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 37 BINARY_SUBSCR       
                 38 JUMP_FORWARD            16 (to 57)
            >>   41 POP_TOP             
                 42 LOAD_FAST                1 (a)
                 45 LOAD_FAST                2 (b)
                 48 BINARY_ADD          
                 49 DUP_TOP             
                 50 LOAD_FAST                0 ($CSECache)
                 53 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 56 STORE_SUBSCR        
            >>   57 LOAD_FAST                0 ($CSECache)
                 60 JUMP_IF_TRUE             9 (to 72)
                 63 BUILD_MAP                0
                 66 STORE_FAST               0 ($CSECache)
                 69 JUMP_FORWARD            20 (to 92)
            >>   72 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 75 COMPARE_OP               6 (in)
                 78 JUMP_IF_FALSE           11 (to 92)
                 81 POP_TOP             
                 82 LOAD_FAST                0 ($CSECache)
                 85 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                 88 BINARY_SUBSCR       
                 89 JUMP_FORWARD            16 (to 108)
            >>   92 POP_TOP             
                 93 LOAD_FAST                1 (a)
                 96 LOAD_FAST                2 (b)
                 99 BINARY_ADD          
                100 DUP_TOP             
                101 LOAD_FAST                0 ($CSECache)
                104 LOAD_CONST               1 ("Add(Local('a'), Local('b')) #1")
                107 STORE_SUBSCR        
            >>  108 BINARY_MULTIPLY     
                109 RETURN_VALUE        


